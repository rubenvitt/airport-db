"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_server_services_redisClient_ts";
exports.ids = ["_ssr_src_server_services_redisClient_ts"];
exports.modules = {

/***/ "(ssr)/./src/server/services/circuitBreaker.ts":
/*!***********************************************!*\
  !*** ./src/server/services/circuitBreaker.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircuitBreaker: () => (/* binding */ CircuitBreaker),\n/* harmony export */   CircuitState: () => (/* binding */ CircuitState),\n/* harmony export */   ExponentialBackoff: () => (/* binding */ ExponentialBackoff)\n/* harmony export */ });\n/* harmony import */ var _lib_cache_observability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/cache/observability */ \"(ssr)/./src/lib/cache/observability/index.ts\");\n// Circuit breaker pattern implementation for resilient service calls\n\nconst logger = new _lib_cache_observability__WEBPACK_IMPORTED_MODULE_0__.StructuredLogger('circuit-breaker', {},  false ? 0 : _lib_cache_observability__WEBPACK_IMPORTED_MODULE_0__.prettyTransport);\nvar CircuitState = /*#__PURE__*/ function(CircuitState) {\n    CircuitState[\"CLOSED\"] = \"CLOSED\";\n    CircuitState[\"OPEN\"] = \"OPEN\";\n    CircuitState[\"HALF_OPEN\"] = \"HALF_OPEN\";\n    return CircuitState;\n}({});\nclass CircuitBreaker {\n    constructor(options){\n        this.state = \"CLOSED\";\n        this.failureCount = 0;\n        this.successCount = 0;\n        this.halfOpenRequestCount = 0;\n        this.name = options.name;\n        this.failureThreshold = options.failureThreshold || 5;\n        this.resetTimeout = options.resetTimeout || 60000 // 1 minute\n        ;\n        this.monitoringPeriod = options.monitoringPeriod || 10000 // 10 seconds\n        ;\n        this.halfOpenRequests = options.halfOpenRequests || 3;\n        this.onStateChange = options.onStateChange;\n    }\n    async execute(fn) {\n        // Check if circuit should transition from OPEN to HALF_OPEN\n        if (this.state === \"OPEN\") {\n            if (this.shouldTransitionToHalfOpen()) {\n                this.transitionTo(\"HALF_OPEN\");\n            } else {\n                throw new Error(`Circuit breaker ${this.name} is OPEN`);\n            }\n        }\n        // In HALF_OPEN state, limit the number of requests\n        if (this.state === \"HALF_OPEN\") {\n            if (this.halfOpenRequestCount >= this.halfOpenRequests) {\n                throw new Error(`Circuit breaker ${this.name} is HALF_OPEN and at request limit`);\n            }\n            this.halfOpenRequestCount++;\n        }\n        try {\n            const result = await fn();\n            this.onSuccess();\n            return result;\n        } catch (error) {\n            this.onFailure();\n            throw error;\n        }\n    }\n    onSuccess() {\n        this.failureCount = 0;\n        this.successCount++;\n        if (this.state === \"HALF_OPEN\") {\n            // If all half-open requests succeed, close the circuit\n            if (this.successCount >= this.halfOpenRequests) {\n                this.transitionTo(\"CLOSED\");\n            }\n        }\n        logger.debug('Circuit breaker request succeeded', {\n            name: this.name,\n            state: this.state,\n            successCount: this.successCount\n        });\n    }\n    onFailure() {\n        this.failureCount++;\n        this.lastFailureTime = Date.now();\n        this.successCount = 0;\n        logger.warn('Circuit breaker request failed', {\n            name: this.name,\n            state: this.state,\n            failureCount: this.failureCount,\n            threshold: this.failureThreshold\n        });\n        if (this.state === \"HALF_OPEN\") {\n            // Any failure in HALF_OPEN state reopens the circuit\n            this.transitionTo(\"OPEN\");\n        } else if (this.state === \"CLOSED\" && this.failureCount >= this.failureThreshold) {\n            // Too many failures in CLOSED state opens the circuit\n            this.transitionTo(\"OPEN\");\n        }\n    }\n    shouldTransitionToHalfOpen() {\n        if (!this.lastFailureTime) return false;\n        return Date.now() - this.lastFailureTime >= this.resetTimeout;\n    }\n    transitionTo(newState) {\n        const oldState = this.state;\n        this.state = newState;\n        // Reset counters on state transition\n        if (newState === \"HALF_OPEN\") {\n            this.halfOpenRequestCount = 0;\n            this.successCount = 0;\n        } else if (newState === \"CLOSED\") {\n            this.failureCount = 0;\n            this.successCount = 0;\n            this.halfOpenRequestCount = 0;\n        }\n        logger.info('Circuit breaker state changed', {\n            name: this.name,\n            oldState,\n            newState\n        });\n        if (this.onStateChange) {\n            this.onStateChange(oldState, newState);\n        }\n    }\n    getState() {\n        return this.state;\n    }\n    getStats() {\n        return {\n            name: this.name,\n            state: this.state,\n            failureCount: this.failureCount,\n            successCount: this.successCount,\n            lastFailureTime: this.lastFailureTime,\n            halfOpenRequestCount: this.halfOpenRequestCount\n        };\n    }\n    reset() {\n        this.transitionTo(\"CLOSED\");\n        this.failureCount = 0;\n        this.successCount = 0;\n        this.lastFailureTime = undefined;\n        this.halfOpenRequestCount = 0;\n    }\n}\n// Exponential backoff helper\nclass ExponentialBackoff {\n    constructor(baseDelay = 1000, maxDelay = 30000, maxAttempts = 5){\n        this.attempt = 0;\n        this.baseDelay = baseDelay;\n        this.maxDelay = maxDelay;\n        this.maxAttempts = maxAttempts;\n    }\n    async execute(fn) {\n        let lastError = new Error('No attempts made');\n        for(let attempt = 0; attempt < this.maxAttempts; attempt++){\n            try {\n                const result = await fn();\n                this.reset();\n                return result;\n            } catch (error) {\n                lastError = error;\n                this.attempt = attempt + 1;\n                if (this.attempt >= this.maxAttempts) {\n                    logger.error('Max retry attempts reached', {\n                        attempts: this.attempt,\n                        maxAttempts: this.maxAttempts\n                    });\n                    throw error;\n                }\n                const delay = this.getDelay();\n                logger.warn('Retrying after backoff', {\n                    attempt: this.attempt,\n                    delay,\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                });\n                await this.sleep(delay);\n            }\n        }\n        throw lastError;\n    }\n    getDelay() {\n        // Exponential backoff with jitter\n        const exponentialDelay = Math.min(this.baseDelay * Math.pow(2, this.attempt - 1), this.maxDelay);\n        // Add jitter (Â±25%)\n        const jitter = exponentialDelay * 0.25;\n        return Math.floor(exponentialDelay + (Math.random() * 2 - 1) * jitter);\n    }\n    sleep(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    reset() {\n        this.attempt = 0;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvc2VydmVyL3NlcnZpY2VzL2NpcmN1aXRCcmVha2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxRUFBcUU7QUFFMkI7QUFFaEcsTUFBTUcsU0FBUyxJQUFJSCxzRUFBZ0JBLENBQ2pDLG1CQUNBLENBQUMsR0FDREksTUFBcUMsR0FBR0gsQ0FBYUEsR0FBR0MscUVBQWVBO0FBR2xFLDBDQUFLRzs7OztXQUFBQTtNQUlYO0FBV00sTUFBTUM7SUFlWEMsWUFBWUMsT0FBOEIsQ0FBRTthQWJwQ0M7YUFDQUMsZUFBZTthQUNmQyxlQUFlO2FBRWZDLHVCQUF1QjtRQVU3QixJQUFJLENBQUNDLElBQUksR0FBR0wsUUFBUUssSUFBSTtRQUN4QixJQUFJLENBQUNDLGdCQUFnQixHQUFHTixRQUFRTSxnQkFBZ0IsSUFBSTtRQUNwRCxJQUFJLENBQUNDLFlBQVksR0FBR1AsUUFBUU8sWUFBWSxJQUFJLE1BQU0sV0FBVzs7UUFDN0QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR1IsUUFBUVEsZ0JBQWdCLElBQUksTUFBTSxhQUFhOztRQUN2RSxJQUFJLENBQUNDLGdCQUFnQixHQUFHVCxRQUFRUyxnQkFBZ0IsSUFBSTtRQUNwRCxJQUFJLENBQUNDLGFBQWEsR0FBR1YsUUFBUVUsYUFBYTtJQUM1QztJQUVBLE1BQU1DLFFBQVdDLEVBQW9CLEVBQWM7UUFDakQsNERBQTREO1FBQzVELElBQUksSUFBSSxDQUFDWCxLQUFLLGFBQXdCO1lBQ3BDLElBQUksSUFBSSxDQUFDWSwwQkFBMEIsSUFBSTtnQkFDckMsSUFBSSxDQUFDQyxZQUFZO1lBQ25CLE9BQU87Z0JBQ0wsTUFBTSxJQUFJQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDVixJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3hEO1FBQ0Y7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSSxJQUFJLENBQUNKLEtBQUssa0JBQTZCO1lBQ3pDLElBQUksSUFBSSxDQUFDRyxvQkFBb0IsSUFBSSxJQUFJLENBQUNL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Q3BDYSxTQUFTLElBQUksQ0FBQ0EsT0FBTztvQkFDckJHO29CQUNBdEIsT0FBT0EsaUJBQWlCSCxRQUFRRyxNQUFNd0IsT0FBTyxHQUFHO2dCQUNsRDtnQkFFQSxNQUFNLElBQUksQ0FBQ0MsS0FBSyxDQUFDSDtZQUNuQjtRQUNGO1FBRUEsTUFBTUY7SUFDUjtJQUVRRyxXQUFtQjtRQUN6QixrQ0FBa0M7UUFDbEMsTUFBTUcsbUJBQW1CQyxLQUFLQyxHQUFHLENBQy9CLElBQUksQ0FBQ1osU0FBUyxHQUFHVyxLQUFLRSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUNWLE9BQU8sR0FBRyxJQUM1QyxJQUFJLENBQUNGLFFBQVE7UUFHZixvQkFBb0I7UUFDcEIsTUFBTWEsU0FBU0osbUJBQW1CO1FBQ2xDLE9BQU9DLEtBQUtJLEtBQUssQ0FBQ0wsbUJBQW1CLENBQUNDLEtBQUtLLE1BQU0sS0FBSyxJQUFJLEtBQUtGO0lBQ2pFO0lBRVFMLE1BQU1RLEVBQVUsRUFBaUI7UUFDdkMsT0FBTyxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTRjtJQUNwRDtJQUVBcEIsUUFBYztRQUNaLElBQUksQ0FBQ00sT0FBTyxHQUFHO0lBQ2pCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydWJlZW4vZGV2L3BlcnNvbmFsL2FpcnBvcnQtZGIvc3JjL3NlcnZlci9zZXJ2aWNlcy9jaXJjdWl0QnJlYWtlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDaXJjdWl0IGJyZWFrZXIgcGF0dGVybiBpbXBsZW1lbnRhdGlvbiBmb3IgcmVzaWxpZW50IHNlcnZpY2UgY2FsbHNcblxuaW1wb3J0IHsgU3RydWN0dXJlZExvZ2dlciwganNvblRyYW5zcG9ydCwgcHJldHR5VHJhbnNwb3J0IH0gZnJvbSAnLi4vLi4vbGliL2NhY2hlL29ic2VydmFiaWxpdHknXG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBTdHJ1Y3R1cmVkTG9nZ2VyKFxuICAnY2lyY3VpdC1icmVha2VyJyxcbiAge30sXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBqc29uVHJhbnNwb3J0IDogcHJldHR5VHJhbnNwb3J0XG4pXG5cbmV4cG9ydCBlbnVtIENpcmN1aXRTdGF0ZSB7XG4gIENMT1NFRCA9ICdDTE9TRUQnLFxuICBPUEVOID0gJ09QRU4nLFxuICBIQUxGX09QRU4gPSAnSEFMRl9PUEVOJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENpcmN1aXRCcmVha2VyT3B0aW9ucyB7XG4gIG5hbWU6IHN0cmluZ1xuICBmYWlsdXJlVGhyZXNob2xkPzogbnVtYmVyXG4gIHJlc2V0VGltZW91dD86IG51bWJlclxuICBtb25pdG9yaW5nUGVyaW9kPzogbnVtYmVyXG4gIGhhbGZPcGVuUmVxdWVzdHM/OiBudW1iZXJcbiAgb25TdGF0ZUNoYW5nZT86IChvbGRTdGF0ZTogQ2lyY3VpdFN0YXRlLCBuZXdTdGF0ZTogQ2lyY3VpdFN0YXRlKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjbGFzcyBDaXJjdWl0QnJlYWtlciB7XG4gIHByaXZhdGUgbmFtZTogc3RyaW5nXG4gIHByaXZhdGUgc3RhdGU6IENpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5DTE9TRURcbiAgcHJpdmF0ZSBmYWlsdXJlQ291bnQgPSAwXG4gIHByaXZhdGUgc3VjY2Vzc0NvdW50ID0gMFxuICBwcml2YXRlIGxhc3RGYWlsdXJlVGltZT86IG51bWJlclxuICBwcml2YXRlIGhhbGZPcGVuUmVxdWVzdENvdW50ID0gMFxuICBcbiAgLy8gQ29uZmlndXJhdGlvblxuICBwcml2YXRlIGZhaWx1cmVUaHJlc2hvbGQ6IG51bWJlclxuICBwcml2YXRlIHJlc2V0VGltZW91dDogbnVtYmVyXG4gIHByaXZhdGUgbW9uaXRvcmluZ1BlcmlvZDogbnVtYmVyXG4gIHByaXZhdGUgaGFsZk9wZW5SZXF1ZXN0czogbnVtYmVyXG4gIHByaXZhdGUgb25TdGF0ZUNoYW5nZT86IChvbGRTdGF0ZTogQ2lyY3VpdFN0YXRlLCBuZXdTdGF0ZTogQ2lyY3VpdFN0YXRlKSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQ2lyY3VpdEJyZWFrZXJPcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lXG4gICAgdGhpcy5mYWlsdXJlVGhyZXNob2xkID0gb3B0aW9ucy5mYWlsdXJlVGhyZXNob2xkIHx8IDVcbiAgICB0aGlzLnJlc2V0VGltZW91dCA9IG9wdGlvbnMucmVzZXRUaW1lb3V0IHx8IDYwMDAwIC8vIDEgbWludXRlXG4gICAgdGhpcy5tb25pdG9yaW5nUGVyaW9kID0gb3B0aW9ucy5tb25pdG9yaW5nUGVyaW9kIHx8IDEwMDAwIC8vIDEwIHNlY29uZHNcbiAgICB0aGlzLmhhbGZPcGVuUmVxdWVzdHMgPSBvcHRpb25zLmhhbGZPcGVuUmVxdWVzdHMgfHwgM1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9wdGlvbnMub25TdGF0ZUNoYW5nZVxuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIC8vIENoZWNrIGlmIGNpcmN1aXQgc2hvdWxkIHRyYW5zaXRpb24gZnJvbSBPUEVOIHRvIEhBTEZfT1BFTlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDaXJjdWl0U3RhdGUuT1BFTikge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkVHJhbnNpdGlvblRvSGFsZk9wZW4oKSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhDaXJjdWl0U3RhdGUuSEFMRl9PUEVOKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWl0IGJyZWFrZXIgJHt0aGlzLm5hbWV9IGlzIE9QRU5gKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIEhBTEZfT1BFTiBzdGF0ZSwgbGltaXQgdGhlIG51bWJlciBvZiByZXF1ZXN0c1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDaXJjdWl0U3RhdGUuSEFMRl9PUEVOKSB7XG4gICAgICBpZiAodGhpcy5oYWxmT3BlblJlcXVlc3RDb3VudCA+PSB0aGlzLmhhbGZPcGVuUmVxdWVzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWl0IGJyZWFrZXIgJHt0aGlzLm5hbWV9IGlzIEhBTEZfT1BFTiBhbmQgYXQgcmVxdWVzdCBsaW1pdGApXG4gICAgICB9XG4gICAgICB0aGlzLmhhbGZPcGVuUmVxdWVzdENvdW50KytcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oKVxuICAgICAgdGhpcy5vblN1Y2Nlc3MoKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLm9uRmFpbHVyZSgpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25TdWNjZXNzKCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMFxuICAgIHRoaXMuc3VjY2Vzc0NvdW50KytcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDaXJjdWl0U3RhdGUuSEFMRl9PUEVOKSB7XG4gICAgICAvLyBJZiBhbGwgaGFsZi1vcGVuIHJlcXVlc3RzIHN1Y2NlZWQsIGNsb3NlIHRoZSBjaXJjdWl0XG4gICAgICBpZiAodGhpcy5zdWNjZXNzQ291bnQgPj0gdGhpcy5oYWxmT3BlblJlcXVlc3RzKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRvKENpcmN1aXRTdGF0ZS5DTE9TRUQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKCdDaXJjdWl0IGJyZWFrZXIgcmVxdWVzdCBzdWNjZWVkZWQnLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgIHN1Y2Nlc3NDb3VudDogdGhpcy5zdWNjZXNzQ291bnRcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBvbkZhaWx1cmUoKTogdm9pZCB7XG4gICAgdGhpcy5mYWlsdXJlQ291bnQrK1xuICAgIHRoaXMubGFzdEZhaWx1cmVUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gMFxuXG4gICAgbG9nZ2VyLndhcm4oJ0NpcmN1aXQgYnJlYWtlciByZXF1ZXN0IGZhaWxlZCcsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgZmFpbHVyZUNvdW50OiB0aGlzLmZhaWx1cmVDb3VudCxcbiAgICAgIHRocmVzaG9sZDogdGhpcy5mYWlsdXJlVGhyZXNob2xkXG4gICAgfSlcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDaXJjdWl0U3RhdGUuSEFMRl9PUEVOKSB7XG4gICAgICAvLyBBbnkgZmFpbHVyZSBpbiBIQUxGX09QRU4gc3RhdGUgcmVvcGVucyB0aGUgY2lyY3VpdFxuICAgICAgdGhpcy50cmFuc2l0aW9uVG8oQ2lyY3VpdFN0YXRlLk9QRU4pXG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDaXJjdWl0U3RhdGUuQ0xPU0VEICYmIHRoaXMuZmFpbHVyZUNvdW50ID49IHRoaXMuZmFpbHVyZVRocmVzaG9sZCkge1xuICAgICAgLy8gVG9vIG1hbnkgZmFpbHVyZXMgaW4gQ0xPU0VEIHN0YXRlIG9wZW5zIHRoZSBjaXJjdWl0XG4gICAgICB0aGlzLnRyYW5zaXRpb25UbyhDaXJjdWl0U3RhdGUuT1BFTilcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFRyYW5zaXRpb25Ub0hhbGZPcGVuKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5sYXN0RmFpbHVyZVRpbWUpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RmFpbHVyZVRpbWUgPj0gdGhpcy5yZXNldFRpbWVvdXRcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNpdGlvblRvKG5ld1N0YXRlOiBDaXJjdWl0U3RhdGUpOiB2b2lkIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuc3RhdGVcbiAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGVcblxuICAgIC8vIFJlc2V0IGNvdW50ZXJzIG9uIHN0YXRlIHRyYW5zaXRpb25cbiAgICBpZiAobmV3U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5IQUxGX09QRU4pIHtcbiAgICAgIHRoaXMuaGFsZk9wZW5SZXF1ZXN0Q291bnQgPSAwXG4gICAgICB0aGlzLnN1Y2Nlc3NDb3VudCA9IDBcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXRlID09PSBDaXJjdWl0U3RhdGUuQ0xPU0VEKSB7XG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDBcbiAgICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gMFxuICAgICAgdGhpcy5oYWxmT3BlblJlcXVlc3RDb3VudCA9IDBcbiAgICB9XG5cbiAgICBsb2dnZXIuaW5mbygnQ2lyY3VpdCBicmVha2VyIHN0YXRlIGNoYW5nZWQnLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIG5ld1N0YXRlXG4gICAgfSlcblxuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZShvbGRTdGF0ZSwgbmV3U3RhdGUpXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdGUoKTogQ2lyY3VpdFN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVxuICB9XG5cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgZmFpbHVyZUNvdW50OiB0aGlzLmZhaWx1cmVDb3VudCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogdGhpcy5zdWNjZXNzQ291bnQsXG4gICAgICBsYXN0RmFpbHVyZVRpbWU6IHRoaXMubGFzdEZhaWx1cmVUaW1lLFxuICAgICAgaGFsZk9wZW5SZXF1ZXN0Q291bnQ6IHRoaXMuaGFsZk9wZW5SZXF1ZXN0Q291bnRcbiAgICB9XG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zaXRpb25UbyhDaXJjdWl0U3RhdGUuQ0xPU0VEKVxuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMFxuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gMFxuICAgIHRoaXMubGFzdEZhaWx1cmVUaW1lID0gdW5kZWZpbmVkXG4gICAgdGhpcy5oYWxmT3BlblJlcXVlc3RDb3VudCA9IDBcbiAgfVxufVxuXG4vLyBFeHBvbmVudGlhbCBiYWNrb2ZmIGhlbHBlclxuZXhwb3J0IGNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XG4gIHByaXZhdGUgYXR0ZW1wdCA9IDBcbiAgcHJpdmF0ZSBiYXNlRGVsYXk6IG51bWJlclxuICBwcml2YXRlIG1heERlbGF5OiBudW1iZXJcbiAgcHJpdmF0ZSBtYXhBdHRlbXB0czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IoXG4gICAgYmFzZURlbGF5ID0gMTAwMCxcbiAgICBtYXhEZWxheSA9IDMwMDAwLFxuICAgIG1heEF0dGVtcHRzID0gNVxuICApIHtcbiAgICB0aGlzLmJhc2VEZWxheSA9IGJhc2VEZWxheVxuICAgIHRoaXMubWF4RGVsYXkgPSBtYXhEZWxheVxuICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBtYXhBdHRlbXB0c1xuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBsYXN0RXJyb3I6IHVua25vd24gPSBuZXcgRXJyb3IoJ05vIGF0dGVtcHRzIG1hZGUnKVxuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgdGhpcy5tYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpXG4gICAgICAgIHRoaXMucmVzZXQoKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvclxuICAgICAgICB0aGlzLmF0dGVtcHQgPSBhdHRlbXB0ICsgMVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdCA+PSB0aGlzLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdNYXggcmV0cnkgYXR0ZW1wdHMgcmVhY2hlZCcsIHtcbiAgICAgICAgICAgIGF0dGVtcHRzOiB0aGlzLmF0dGVtcHQsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogdGhpcy5tYXhBdHRlbXB0c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5nZXREZWxheSgpXG4gICAgICAgIGxvZ2dlci53YXJuKCdSZXRyeWluZyBhZnRlciBiYWNrb2ZmJywge1xuICAgICAgICAgIGF0dGVtcHQ6IHRoaXMuYXR0ZW1wdCxcbiAgICAgICAgICBkZWxheSxcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMuc2xlZXAoZGVsYXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbGFzdEVycm9yXG4gIH1cblxuICBwcml2YXRlIGdldERlbGF5KCk6IG51bWJlciB7XG4gICAgLy8gRXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGppdHRlclxuICAgIGNvbnN0IGV4cG9uZW50aWFsRGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIHRoaXMuYmFzZURlbGF5ICogTWF0aC5wb3coMiwgdGhpcy5hdHRlbXB0IC0gMSksXG4gICAgICB0aGlzLm1heERlbGF5XG4gICAgKVxuICAgIFxuICAgIC8vIEFkZCBqaXR0ZXIgKMKxMjUlKVxuICAgIGNvbnN0IGppdHRlciA9IGV4cG9uZW50aWFsRGVsYXkgKiAwLjI1XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZXhwb25lbnRpYWxEZWxheSArIChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogaml0dGVyKVxuICB9XG5cbiAgcHJpdmF0ZSBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpXG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmF0dGVtcHQgPSAwXG4gIH1cbn0iXSwibmFtZXMiOlsiU3RydWN0dXJlZExvZ2dlciIsImpzb25UcmFuc3BvcnQiLCJwcmV0dHlUcmFuc3BvcnQiLCJsb2dnZXIiLCJwcm9jZXNzIiwiQ2lyY3VpdFN0YXRlIiwiQ2lyY3VpdEJyZWFrZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzdGF0ZSIsImZhaWx1cmVDb3VudCIsInN1Y2Nlc3NDb3VudCIsImhhbGZPcGVuUmVxdWVzdENvdW50IiwibmFtZSIsImZhaWx1cmVUaHJlc2hvbGQiLCJyZXNldFRpbWVvdXQiLCJtb25pdG9yaW5nUGVyaW9kIiwiaGFsZk9wZW5SZXF1ZXN0cyIsIm9uU3RhdGVDaGFuZ2UiLCJleGVjdXRlIiwiZm4iLCJzaG91bGRUcmFuc2l0aW9uVG9IYWxmT3BlbiIsInRyYW5zaXRpb25UbyIsIkVycm9yIiwicmVzdWx0Iiwib25TdWNjZXNzIiwiZXJyb3IiLCJvbkZhaWx1cmUiLCJkZWJ1ZyIsImxhc3RGYWlsdXJlVGltZSIsIkRhdGUiLCJub3ciLCJ3YXJuIiwidGhyZXNob2xkIiwibmV3U3RhdGUiLCJvbGRTdGF0ZSIsImluZm8iLCJnZXRTdGF0ZSIsImdldFN0YXRzIiwicmVzZXQiLCJ1bmRlZmluZWQiLCJFeHBvbmVudGlhbEJhY2tvZmYiLCJiYXNlRGVsYXkiLCJtYXhEZWxheSIsIm1heEF0dGVtcHRzIiwiYXR0ZW1wdCIsImxhc3RFcnJvciIsImF0dGVtcHRzIiwiZGVsYXkiLCJnZXREZWxheSIsIm1lc3NhZ2UiLCJzbGVlcCIsImV4cG9uZW50aWFsRGVsYXkiLCJNYXRoIiwibWluIiwicG93Iiwiaml0dGVyIiwiZmxvb3IiLCJyYW5kb20iLCJtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/server/services/circuitBreaker.ts\n");

/***/ }),

/***/ "(ssr)/./src/server/services/redisClient.ts":
/*!********************************************!*\
  !*** ./src/server/services/redisClient.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeRedisClient: () => (/* binding */ closeRedisClient),\n/* harmony export */   getRedisCircuitBreaker: () => (/* binding */ getRedisCircuitBreaker),\n/* harmony export */   getRedisClient: () => (/* binding */ getRedisClient),\n/* harmony export */   getRedisConfig: () => (/* binding */ getRedisConfig)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_cache_observability__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/cache/observability */ \"(ssr)/./src/lib/cache/observability/index.ts\");\n/* harmony import */ var _circuitBreaker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circuitBreaker */ \"(ssr)/./src/server/services/circuitBreaker.ts\");\n/* harmony import */ var _secretsManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secretsManager */ \"(ssr)/./src/server/services/secretsManager.ts\");\n// Redis client configuration and initialization\n\n\n\n\n// Load environment variables for server-side only\nif (true) {\n    await __webpack_require__.e(/*! import() */ \"vendor-chunks/dotenv@16.5.0\").then(__webpack_require__.t.bind(__webpack_require__, /*! dotenv */ \"(ssr)/./node_modules/.pnpm/dotenv@16.5.0/node_modules/dotenv/lib/main.js\", 23)).then((mod)=>mod.config());\n}\nconst logger = new _lib_cache_observability__WEBPACK_IMPORTED_MODULE_1__.StructuredLogger('redis', {},  false ? 0 : _lib_cache_observability__WEBPACK_IMPORTED_MODULE_1__.prettyTransport);\nlet redisClient = null;\nlet circuitBreaker = null;\nasync function getRedisConfig() {\n    const config = {};\n    // Initialize secrets manager\n    await _secretsManager__WEBPACK_IMPORTED_MODULE_3__.secretsManager.initialize();\n    const secrets = await _secretsManager__WEBPACK_IMPORTED_MODULE_3__.secretsManager.getAllSecrets();\n    if (true) {\n        config.url = \"redis://localhost:9021\";\n    } else {}\n    // TLS Configuration\n    if (process.env.REDIS_TLS_ENABLED === 'true') {\n        config.tls = {\n            rejectUnauthorized: process.env.REDIS_TLS_REJECT_UNAUTHORIZED !== 'false'\n        };\n        // Use secrets for TLS certificates\n        if (secrets.redisTlsCa) {\n            config.tls.ca = secrets.redisTlsCa;\n        }\n        if (secrets.redisTlsCert) {\n            config.tls.cert = secrets.redisTlsCert;\n        }\n        if (secrets.redisTlsKey) {\n            config.tls.key = secrets.redisTlsKey;\n        }\n        if (process.env.REDIS_TLS_SERVERNAME) {\n            config.tls.servername = process.env.REDIS_TLS_SERVERNAME;\n        }\n    }\n    // Connection resilience settings\n    config.maxRetriesPerRequest = 3;\n    config.enableReadyCheck = true;\n    config.retryStrategy = (times)=>{\n        if (times > 3) {\n            logger.error('Redis connection failed after 3 retries');\n            return null // Stop retrying\n            ;\n        }\n        const delay = Math.min(times * 200, 2000);\n        logger.warn(`Redis connection attempt ${times}, retrying in ${delay}ms`, {\n            attempt: times,\n            delay\n        });\n        return delay;\n    };\n    return config;\n}\n// Initialize circuit breaker for Redis operations\nfunction initializeCircuitBreaker() {\n    if (!circuitBreaker) {\n        circuitBreaker = new _circuitBreaker__WEBPACK_IMPORTED_MODULE_2__.CircuitBreaker({\n            name: 'redis',\n            failureThreshold: parseInt(process.env.REDIS_CIRCUIT_FAILURE_THRESHOLD || '5', 10),\n            resetTimeout: parseInt(process.env.REDIS_CIRCUIT_RESET_TIMEOUT || '60000', 10),\n            halfOpenRequests: parseInt(process.env.REDIS_CIRCUIT_HALF_OPEN_REQUESTS || '3', 10),\n            onStateChange: (oldState, newState)=>{\n                logger.warn('Redis circuit breaker state changed', {\n                    oldState,\n                    newState\n                });\n            }\n        });\n    }\n    return circuitBreaker;\n}\nasync function getRedisClient() {\n    // Only initialize Redis on server\n    if (false) {}\n    if (redisClient && redisClient.status === 'ready') {\n        return redisClient;\n    }\n    // Initialize circuit breaker\n    const breaker = initializeCircuitBreaker();\n    try {\n        // Use circuit breaker for connection attempt\n        return await breaker.execute(async ()=>{\n            const config = await getRedisConfig();\n            logger.info('Initializing Redis connection', {\n                host: config.host,\n                port: config.port,\n                url: config.url ? 'configured' : 'not configured'\n            });\n            redisClient = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())(config.url || config);\n            redisClient.on('connect', ()=>{\n                logger.info('Redis client connected');\n            });\n            redisClient.on('error', (err)=>{\n                logger.error('Redis client error', err);\n            });\n            redisClient.on('ready', ()=>{\n                logger.info('Redis client ready to accept commands');\n            });\n            redisClient.on('close', ()=>{\n                logger.warn('Redis connection closed');\n            });\n            redisClient.on('reconnecting', (delay)=>{\n                logger.info('Redis reconnecting', {\n                    delay\n                });\n            });\n            // Test the connection\n            await redisClient.ping();\n            logger.info('Redis connection established and tested');\n            return redisClient;\n        });\n    } catch (error) {\n        logger.error('Failed to initialize Redis client', error);\n        redisClient = null;\n        return null;\n    }\n}\nfunction getRedisCircuitBreaker() {\n    return circuitBreaker || initializeCircuitBreaker();\n}\nasync function closeRedisClient() {\n    if (redisClient) {\n        logger.info('Closing Redis connection');\n        await redisClient.quit();\n        redisClient = null;\n    }\n}\n// Graceful shutdown\nif (true) {\n    process.on('SIGTERM', async ()=>{\n        await closeRedisClient();\n    });\n    process.on('SIGINT', async ()=>{\n        await closeRedisClient();\n    });\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvc2VydmVyL3NlcnZpY2VzL3JlZGlzQ2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxnREFBZ0Q7QUFFckI7QUFDcUU7QUFDYjtBQUNsQztBQUVqRCxrREFBa0Q7QUFDbEQsSUFBSSxJQUE2QixFQUFFO0lBQ2pDLE1BQU0sd05BQWdCLENBQUNNLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsTUFBTTtBQUMvQztBQUVBLE1BQU1DLFNBQVMsSUFBSVIsc0VBQWdCQSxDQUNqQyxTQUNBLENBQUMsR0FDRFMsTUFBcUMsR0FBR1IsQ0FBYUEsR0FBR0MscUVBQWVBO0FBcUJ6RSxJQUFJUSxjQUE0QjtBQUNoQyxJQUFJQyxpQkFBd0M7QUFFckMsZUFBZUM7SUFDcEIsTUFBTUwsU0FBc0IsQ0FBQztJQUU3Qiw2QkFBNkI7SUFDN0IsTUFBTUgsMkRBQWNBLENBQUNTLFVBQVU7SUFDL0IsTUFBTUMsVUFBVSxNQUFNViwyREFBY0EsQ0FBQ1csYUFBYTtJQUVsRCxJQUFJTixJQUFxQixFQUFFO1FBQ3pCRixPQUFPVyxHQUFHLEdBQUdULHdCQUFxQjtJQUNwQyxPQUFPLEVBV047SUFFRCxvQkFBb0I7SUFDcEIsSUFBSUEsUUFBUU8sR0FBRyxDQUFDWSxpQkFBaUIsS0FBSyxRQUFRO1FBQzVDckIsT0FBT3NCLEdBQUcsR0FBRztZQUNYQyxvQkFBb0JyQixRQUFRTyxHQUFHLENBQUNlLDZCQUE2QixLQUFLO1FBQ3BFO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlqQixRQUFRa0IsVUFBVSxFQUFFO1lBQ3RCekIsT0FBT3NCLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHbkIsUUFBUWtCLFVBQVU7UUFDcEM7UUFFQSxJQUFJbEIsUUFBUW9CLFlBQVksRUFBRTtZQUN4QjNCLE9BQU9zQixHQUFHLENBQUNNLElBQUksR0FBR3JCLFFBQVFvQixZQUFZO1FBQ3hDO1FBRUEsSUFBSXBCLFFBQVFzQixXQUFXLEVBQUU7WUFDdkI3QixPQUFPc0IsR0FBRyxD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TzFELGtCQUFrQnVDO0FBQzNCO0FBRU8sZUFBZW9CO0lBQ3BCLElBQUk1RCxhQUFhO1FBQ2ZGLE9BQU95RCxJQUFJLENBQUM7UUFDWixNQUFNdkQsWUFBWTZELElBQUk7UUFDdEI3RCxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQSxvQkFBb0I7QUFDcEIsSUFBSSxJQUE2QixFQUFFO0lBQ2pDRCxRQUFReUQsRUFBRSxDQUFDLFdBQVc7UUFDcEIsTUFBTUk7SUFDUjtJQUVBN0QsUUFBUXlELEVBQUUsQ0FBQyxVQUFVO1FBQ25CLE1BQU1JO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3J1YmVlbi9kZXYvcGVyc29uYWwvYWlycG9ydC1kYi9zcmMvc2VydmVyL3NlcnZpY2VzL3JlZGlzQ2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlZGlzIGNsaWVudCBjb25maWd1cmF0aW9uIGFuZCBpbml0aWFsaXphdGlvblxuXG5pbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcydcbmltcG9ydCB7IFN0cnVjdHVyZWRMb2dnZXIsIGpzb25UcmFuc3BvcnQsIHByZXR0eVRyYW5zcG9ydCB9IGZyb20gJy4uLy4uL2xpYi9jYWNoZS9vYnNlcnZhYmlsaXR5J1xuaW1wb3J0IHsgQ2lyY3VpdEJyZWFrZXIsIENpcmN1aXRTdGF0ZSwgRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnLi9jaXJjdWl0QnJlYWtlcidcbmltcG9ydCB7IHNlY3JldHNNYW5hZ2VyIH0gZnJvbSAnLi9zZWNyZXRzTWFuYWdlcidcblxuLy8gTG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHNlcnZlci1zaWRlIG9ubHlcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBhd2FpdCBpbXBvcnQoJ2RvdGVudicpLnRoZW4obW9kID0+IG1vZC5jb25maWcoKSlcbn1cblxuY29uc3QgbG9nZ2VyID0gbmV3IFN0cnVjdHVyZWRMb2dnZXIoXG4gICdyZWRpcycsXG4gIHt9LFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8ganNvblRyYW5zcG9ydCA6IHByZXR0eVRyYW5zcG9ydFxuKVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZGlzQ29uZmlnIHtcbiAgdXJsPzogc3RyaW5nXG4gIGhvc3Q/OiBzdHJpbmdcbiAgcG9ydD86IG51bWJlclxuICBwYXNzd29yZD86IHN0cmluZ1xuICB1c2VybmFtZT86IHN0cmluZ1xuICBtYXhSZXRyaWVzUGVyUmVxdWVzdD86IG51bWJlclxuICBlbmFibGVSZWFkeUNoZWNrPzogYm9vbGVhblxuICByZXRyeVN0cmF0ZWd5PzogKHRpbWVzOiBudW1iZXIpID0+IG51bWJlciB8IHZvaWRcbiAgdGxzPzoge1xuICAgIGNhPzogc3RyaW5nIHwgQnVmZmVyXG4gICAgY2VydD86IHN0cmluZyB8IEJ1ZmZlclxuICAgIGtleT86IHN0cmluZyB8IEJ1ZmZlclxuICAgIHJlamVjdFVuYXV0aG9yaXplZD86IGJvb2xlYW5cbiAgICBzZXJ2ZXJuYW1lPzogc3RyaW5nXG4gIH1cbn1cblxubGV0IHJlZGlzQ2xpZW50OiBSZWRpcyB8IG51bGwgPSBudWxsXG5sZXQgY2lyY3VpdEJyZWFrZXI6IENpcmN1aXRCcmVha2VyIHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlZGlzQ29uZmlnKCk6IFByb21pc2U8UmVkaXNDb25maWc+IHtcbiAgY29uc3QgY29uZmlnOiBSZWRpc0NvbmZpZyA9IHt9XG5cbiAgLy8gSW5pdGlhbGl6ZSBzZWNyZXRzIG1hbmFnZXJcbiAgYXdhaXQgc2VjcmV0c01hbmFnZXIuaW5pdGlhbGl6ZSgpXG4gIGNvbnN0IHNlY3JldHMgPSBhd2FpdCBzZWNyZXRzTWFuYWdlci5nZXRBbGxTZWNyZXRzKClcblxuICBpZiAocHJvY2Vzcy5lbnYuUkVESVNfVVJMKSB7XG4gICAgY29uZmlnLnVybCA9IHByb2Nlc3MuZW52LlJFRElTX1VSTFxuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5ob3N0ID0gcHJvY2Vzcy5lbnYuUkVESVNfSE9TVCB8fCAnbG9jYWxob3N0J1xuICAgIGNvbmZpZy5wb3J0ID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfUE9SVCB8fCAnOTAyMScsIDEwKVxuICAgIFxuICAgIC8vIFVzZSBzZWNyZXRzIG1hbmFnZXIgZm9yIGNyZWRlbnRpYWxzXG4gICAgaWYgKHNlY3JldHMucmVkaXNQYXNzd29yZCkge1xuICAgICAgY29uZmlnLnBhc3N3b3JkID0gc2VjcmV0cy5yZWRpc1Bhc3N3b3JkXG4gICAgfVxuICAgIGlmIChzZWNyZXRzLnJlZGlzVXNlcm5hbWUpIHtcbiAgICAgIGNvbmZpZy51c2VybmFtZSA9IHNlY3JldHMucmVkaXNVc2VybmFtZVxuICAgIH1cbiAgfVxuXG4gIC8vIFRMUyBDb25maWd1cmF0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5SRURJU19UTFNfRU5BQkxFRCA9PT0gJ3RydWUnKSB7XG4gICAgY29uZmlnLnRscyA9IHtcbiAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogcHJvY2Vzcy5lbnYuUkVESVNfVExTX1JFSkVDVF9VTkFVVEhPUklaRUQgIT09ICdmYWxzZSdcbiAgICB9XG5cbiAgICAvLyBVc2Ugc2VjcmV0cyBmb3IgVExTIGNlcnRpZmljYXRlc1xuICAgIGlmIChzZWNyZXRzLnJlZGlzVGxzQ2EpIHtcbiAgICAgIGNvbmZpZy50bHMuY2EgPSBzZWNyZXRzLnJlZGlzVGxzQ2FcbiAgICB9XG5cbiAgICBpZiAoc2VjcmV0cy5yZWRpc1Rsc0NlcnQpIHtcbiAgICAgIGNvbmZpZy50bHMuY2VydCA9IHNlY3JldHMucmVkaXNUbHNDZXJ0XG4gICAgfVxuXG4gICAgaWYgKHNlY3JldHMucmVkaXNUbHNLZXkpIHtcbiAgICAgIGNvbmZpZy50bHMua2V5ID0gc2VjcmV0cy5yZWRpc1Rsc0tleVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5SRURJU19UTFNfU0VSVkVSTkFNRSkge1xuICAgICAgY29uZmlnLnRscy5zZXJ2ZXJuYW1lID0gcHJvY2Vzcy5lbnYuUkVESVNfVExTX1NFUlZFUk5BTUVcbiAgICB9XG4gIH1cblxuICAvLyBDb25uZWN0aW9uIHJlc2lsaWVuY2Ugc2V0dGluZ3NcbiAgY29uZmlnLm1heFJldHJpZXNQZXJSZXF1ZXN0ID0gM1xuICBjb25maWcuZW5hYmxlUmVhZHlDaGVjayA9IHRydWVcbiAgY29uZmlnLnJldHJ5U3RyYXRlZ3kgPSAodGltZXM6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aW1lcyA+IDMpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignUmVkaXMgY29ubmVjdGlvbiBmYWlsZWQgYWZ0ZXIgMyByZXRyaWVzJylcbiAgICAgIHJldHVybiBudWxsIC8vIFN0b3AgcmV0cnlpbmdcbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbih0aW1lcyAqIDIwMCwgMjAwMClcbiAgICBsb2dnZXIud2FybihgUmVkaXMgY29ubmVjdGlvbiBhdHRlbXB0ICR7dGltZXN9LCByZXRyeWluZyBpbiAke2RlbGF5fW1zYCwgeyBhdHRlbXB0OiB0aW1lcywgZGVsYXkgfSlcbiAgICByZXR1cm4gZGVsYXlcbiAgfVxuXG4gIHJldHVybiBjb25maWdcbn1cblxuLy8gSW5pdGlhbGl6ZSBjaXJjdWl0IGJyZWFrZXIgZm9yIFJlZGlzIG9wZXJhdGlvbnNcbmZ1bmN0aW9uIGluaXRpYWxpemVDaXJjdWl0QnJlYWtlcigpOiBDaXJjdWl0QnJlYWtlciB7XG4gIGlmICghY2lyY3VpdEJyZWFrZXIpIHtcbiAgICBjaXJjdWl0QnJlYWtlciA9IG5ldyBDaXJjdWl0QnJlYWtlcih7XG4gICAgICBuYW1lOiAncmVkaXMnLFxuICAgICAgZmFpbHVyZVRocmVzaG9sZDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfQ0lSQ1VJVF9GQUlMVVJFX1RIUkVTSE9MRCB8fCAnNScsIDEwKSxcbiAgICAgIHJlc2V0VGltZW91dDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfQ0lSQ1VJVF9SRVNFVF9USU1FT1VUIHx8ICc2MDAwMCcsIDEwKSxcbiAgICAgIGhhbGZPcGVuUmVxdWVzdHM6IHBhcnNlSW50KHByb2Nlc3MuZW52LlJFRElTX0NJUkNVSVRfSEFMRl9PUEVOX1JFUVVFU1RTIHx8ICczJywgMTApLFxuICAgICAgb25TdGF0ZUNoYW5nZTogKG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICBsb2dnZXIud2FybignUmVkaXMgY2lyY3VpdCBicmVha2VyIHN0YXRlIGNoYW5nZWQnLCB7IG9sZFN0YXRlLCBuZXdTdGF0ZSB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGNpcmN1aXRCcmVha2VyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWRpc0NsaWVudCgpOiBQcm9taXNlPFJlZGlzIHwgbnVsbD4ge1xuICAvLyBPbmx5IGluaXRpYWxpemUgUmVkaXMgb24gc2VydmVyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAocmVkaXNDbGllbnQgJiYgcmVkaXNDbGllbnQuc3RhdHVzID09PSAncmVhZHknKSB7XG4gICAgcmV0dXJuIHJlZGlzQ2xpZW50XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGNpcmN1aXQgYnJlYWtlclxuICBjb25zdCBicmVha2VyID0gaW5pdGlhbGl6ZUNpcmN1aXRCcmVha2VyKClcblxuICB0cnkge1xuICAgIC8vIFVzZSBjaXJjdWl0IGJyZWFrZXIgZm9yIGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgIHJldHVybiBhd2FpdCBicmVha2VyLmV4ZWN1dGUoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgZ2V0UmVkaXNDb25maWcoKVxuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnSW5pdGlhbGl6aW5nIFJlZGlzIGNvbm5lY3Rpb24nLCB7IFxuICAgICAgICBob3N0OiBjb25maWcuaG9zdCwgXG4gICAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgICB1cmw6IGNvbmZpZy51cmwgPyAnY29uZmlndXJlZCcgOiAnbm90IGNvbmZpZ3VyZWQnXG4gICAgICB9KVxuICAgICAgXG4gICAgICByZWRpc0NsaWVudCA9IG5ldyBSZWRpcyhjb25maWcudXJsIHx8IGNvbmZpZylcblxuICAgICAgcmVkaXNDbGllbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdSZWRpcyBjbGllbnQgY29ubmVjdGVkJylcbiAgICAgIH0pXG5cbiAgICAgIHJlZGlzQ2xpZW50Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWRpcyBjbGllbnQgZXJyb3InLCBlcnIpXG4gICAgICB9KVxuXG4gICAgICByZWRpc0NsaWVudC5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdSZWRpcyBjbGllbnQgcmVhZHkgdG8gYWNjZXB0IGNvbW1hbmRzJylcbiAgICAgIH0pXG5cbiAgICAgIHJlZGlzQ2xpZW50Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1JlZGlzIGNvbm5lY3Rpb24gY2xvc2VkJylcbiAgICAgIH0pXG5cbiAgICAgIHJlZGlzQ2xpZW50Lm9uKCdyZWNvbm5lY3RpbmcnLCAoZGVsYXk6IG51bWJlcikgPT4ge1xuICAgICAgICBsb2dnZXIuaW5mbygnUmVkaXMgcmVjb25uZWN0aW5nJywgeyBkZWxheSB9KVxuICAgICAgfSlcblxuICAgICAgLy8gVGVzdCB0aGUgY29ubmVjdGlvblxuICAgICAgYXdhaXQgcmVkaXNDbGllbnQucGluZygpXG4gICAgICBsb2dnZXIuaW5mbygnUmVkaXMgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCBhbmQgdGVzdGVkJylcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlZGlzQ2xpZW50XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFJlZGlzIGNsaWVudCcsIGVycm9yIGFzIEVycm9yKVxuICAgIHJlZGlzQ2xpZW50ID0gbnVsbFxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZGlzQ2lyY3VpdEJyZWFrZXIoKTogQ2lyY3VpdEJyZWFrZXIgfCBudWxsIHtcbiAgcmV0dXJuIGNpcmN1aXRCcmVha2VyIHx8IGluaXRpYWxpemVDaXJjdWl0QnJlYWtlcigpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9zZVJlZGlzQ2xpZW50KCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAocmVkaXNDbGllbnQpIHtcbiAgICBsb2dnZXIuaW5mbygnQ2xvc2luZyBSZWRpcyBjb25uZWN0aW9uJylcbiAgICBhd2FpdCByZWRpc0NsaWVudC5xdWl0KClcbiAgICByZWRpc0NsaWVudCA9IG51bGxcbiAgfVxufVxuXG4vLyBHcmFjZWZ1bCBzaHV0ZG93blxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHByb2Nlc3Mub24oJ1NJR1RFUk0nLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY2xvc2VSZWRpc0NsaWVudCgpXG4gIH0pXG4gIFxuICBwcm9jZXNzLm9uKCdTSUdJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY2xvc2VSZWRpc0NsaWVudCgpXG4gIH0pXG59Il0sIm5hbWVzIjpbIlJlZGlzIiwiU3RydWN0dXJlZExvZ2dlciIsImpzb25UcmFuc3BvcnQiLCJwcmV0dHlUcmFuc3BvcnQiLCJDaXJjdWl0QnJlYWtlciIsInNlY3JldHNNYW5hZ2VyIiwidGhlbiIsIm1vZCIsImNvbmZpZyIsImxvZ2dlciIsInByb2Nlc3MiLCJyZWRpc0NsaWVudCIsImNpcmN1aXRCcmVha2VyIiwiZ2V0UmVkaXNDb25maWciLCJpbml0aWFsaXplIiwic2VjcmV0cyIsImdldEFsbFNlY3JldHMiLCJlbnYiLCJSRURJU19VUkwiLCJ1cmwiLCJob3N0IiwiUkVESVNfSE9TVCIsInBvcnQiLCJwYXJzZUludCIsIlJFRElTX1BPUlQiLCJyZWRpc1Bhc3N3b3JkIiwicGFzc3dvcmQiLCJyZWRpc1VzZXJuYW1lIiwidXNlcm5hbWUiLCJSRURJU19UTFNfRU5BQkxFRCIsInRscyIsInJlamVjdFVuYXV0aG9yaXplZCIsIlJFRElTX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEIiwicmVkaXNUbHNDYSIsImNhIiwicmVkaXNUbHNDZXJ0IiwiY2VydCIsInJlZGlzVGxzS2V5Iiwia2V5IiwiUkVESVNfVExTX1NFUlZFUk5BTUUiLCJzZXJ2ZXJuYW1lIiwibWF4UmV0cmllc1BlclJlcXVlc3QiLCJlbmFibGVSZWFkeUNoZWNrIiwicmV0cnlTdHJhdGVneSIsInRpbWVzIiwiZXJyb3IiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJ3YXJuIiwiYXR0ZW1wdCIsImluaXRpYWxpemVDaXJjdWl0QnJlYWtlciIsIm5hbWUiLCJmYWlsdXJlVGhyZXNob2xkIiwiUkVESVNfQ0lSQ1VJVF9GQUlMVVJFX1RIUkVTSE9MRCIsInJlc2V0VGltZW91dCIsIlJFRElTX0NJUkNVSVRfUkVTRVRfVElNRU9VVCIsImhhbGZPcGVuUmVxdWVzdHMiLCJSRURJU19DSVJDVUlUX0hBTEZfT1BFTl9SRVFVRVNUUyIsIm9uU3RhdGVDaGFuZ2UiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwiZ2V0UmVkaXNDbGllbnQiLCJzdGF0dXMiLCJicmVha2VyIiwiZXhlY3V0ZSIsImluZm8iLCJvbiIsImVyciIsInBpbmciLCJnZXRSZWRpc0NpcmN1aXRCcmVha2VyIiwiY2xvc2VSZWRpc0NsaWVudCIsInF1aXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/server/services/redisClient.ts\n");

/***/ }),

/***/ "(ssr)/./src/server/services/secretsManager.ts":
/*!***********************************************!*\
  !*** ./src/server/services/secretsManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   secretsManager: () => (/* binding */ secretsManager)\n/* harmony export */ });\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_cache_observability__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/cache/observability */ \"(ssr)/./src/lib/cache/observability/index.ts\");\n// Secrets Manager for Redis and other sensitive credentials\n// Supports multiple secret sources: environment variables, files, and external services\n\n\n\n\nconst logger = new _lib_cache_observability__WEBPACK_IMPORTED_MODULE_3__.StructuredLogger('secrets-manager', {},  false ? 0 : _lib_cache_observability__WEBPACK_IMPORTED_MODULE_3__.prettyTransport);\nclass SecretsManager {\n    constructor(){\n        this.cache = new Map();\n        this.secretsPath = process.env.SECRETS_PATH || path__WEBPACK_IMPORTED_MODULE_1__.join(process.cwd(), '.secrets');\n        // Initialize encryption key from environment or generate one\n        if (process.env.SECRETS_ENCRYPTION_KEY) {\n            this.encryptionKey = Buffer.from(process.env.SECRETS_ENCRYPTION_KEY, 'hex');\n        }\n    }\n    async initialize() {\n        // Create secrets directory if it doesn't exist\n        try {\n            await fs_promises__WEBPACK_IMPORTED_MODULE_0__.mkdir(this.secretsPath, {\n                recursive: true,\n                mode: 448\n            });\n        } catch (error) {\n            logger.error('Failed to create secrets directory', error);\n        }\n    }\n    // Get secret from various sources\n    async getSecret(name, config) {\n        const cacheKey = `${config.source}:${name}`;\n        // Check cache first\n        if (this.cache.has(cacheKey)) {\n            return this.cache.get(cacheKey);\n        }\n        let secret;\n        switch(config.source){\n            case 'env':\n                secret = process.env[config.key || name];\n                break;\n            case 'file':\n                secret = await this.readSecretFromFile(config.path || name);\n                break;\n            case 'vault':\n                secret = await this.readFromHashicorpVault(name, config);\n                break;\n            case 'aws-secrets-manager':\n                secret = await this.readFromAWSSecretsManager(name, config);\n                break;\n            case 'gcp-secret-manager':\n                secret = await this.readFromGCPSecretManager(name, config);\n                break;\n        }\n        // Decrypt if needed\n        if (secret && config.decrypt && this.encryptionKey) {\n            secret = this.decrypt(secret);\n        }\n        // Cache the secret\n        if (secret) {\n            this.cache.set(cacheKey, secret);\n        }\n        return secret;\n    }\n    // Read secret from file\n    async readSecretFromFile(filename) {\n        try {\n            const filePath = path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute(filename) ? filename : path__WEBPACK_IMPORTED_MODULE_1__.join(this.secretsPath, filename);\n            const content = await fs_promises__WEBPACK_IMPORTED_MODULE_0__.readFile(filePath, 'utf8');\n            return content.trim();\n        } catch (error) {\n            if (error.code !== 'ENOENT') {\n                logger.error(`Failed to read secret from file: ${filename}`, error);\n            }\n            return undefined;\n        }\n    }\n    // Placeholder for HashiCorp Vault integration\n    async readFromHashicorpVault(name, config) {\n        // Implementation would require vault client library\n        logger.warn('HashiCorp Vault integration not implemented', {\n            name\n        });\n        return undefined;\n    }\n    // Placeholder for AWS Secrets Manager integration\n    async readFromAWSSecretsManager(name, config) {\n        // Implementation would require AWS SDK\n        logger.warn('AWS Secrets Manager integration not implemented', {\n            name\n        });\n        return undefined;\n    }\n    // Placeholder for GCP Secret Manager integration\n    async readFromGCPSecretManager(name, config) {\n        // Implementation would require GCP client library\n        logger.warn('GCP Secret Manager integration not implemented', {\n            name\n        });\n        return undefined;\n    }\n    // Get all secrets with fallback to environment variables\n    async getAllSecrets() {\n        const secrets = {};\n        // Redis credentials\n        secrets.redisPassword = await this.getSecret('REDIS_PASSWORD', {\n            source: process.env.SECRETS_SOURCE || 'env',\n            key: 'REDIS_PASSWORD'\n        }) || process.env.REDIS_PASSWORD;\n        secrets.redisUsername = await this.getSecret('REDIS_USERNAME', {\n            source: process.env.SECRETS_SOURCE || 'env',\n            key: 'REDIS_USERNAME'\n        }) || process.env.REDIS_USERNAME || 'airport-app';\n        // TLS certificates\n        if (process.env.REDIS_TLS_ENABLED === 'true') {\n            secrets.redisTlsCa = await this.getSecret('REDIS_TLS_CA', {\n                source: 'file',\n                path: process.env.REDIS_TLS_CA || 'redis/tls/ca.crt'\n            });\n            secrets.redisTlsCert = await this.getSecret('REDIS_TLS_CERT', {\n                source: 'file',\n                path: process.env.REDIS_TLS_CERT || 'redis/tls/client.crt'\n            });\n            secrets.redisTlsKey = await this.getSecret('REDIS_TLS_KEY', {\n                source: 'file',\n                path: process.env.REDIS_TLS_KEY || 'redis/tls/client.key'\n            });\n        }\n        // API keys\n        secrets.apiNinjasKey = await this.getSecret('VITE_API_NINJAS_API_KEY', {\n            source: process.env.SECRETS_SOURCE || 'env',\n            key: 'VITE_API_NINJAS_API_KEY'\n        });\n        secrets.openSkyUsername = await this.getSecret('VITE_OPENSKY_USERNAME', {\n            source: process.env.SECRETS_SOURCE || 'env',\n            key: 'VITE_OPENSKY_USERNAME'\n        });\n        secrets.openSkyPassword = await this.getSecret('VITE_OPENSKY_PASSWORD', {\n            source: process.env.SECRETS_SOURCE || 'env',\n            key: 'VITE_OPENSKY_PASSWORD'\n        });\n        return secrets;\n    }\n    // Generate secure random password\n    generatePassword(length = 32) {\n        const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=';\n        const randomBytes = crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes(length);\n        let password = '';\n        for(let i = 0; i < length; i++){\n            password += charset[randomBytes[i] % charset.length];\n        }\n        return password;\n    }\n    // Save secret to file (for development/setup)\n    async saveSecret(name, value, encrypt = false) {\n        const filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.secretsPath, name);\n        let content = value;\n        if (encrypt && this.encryptionKey) {\n            content = this.encrypt(value);\n        }\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile(filePath, content, {\n            mode: 384\n        });\n        logger.info(`Secret saved: ${name}`);\n    }\n    // Simple encryption for at-rest protection\n    encrypt(text) {\n        if (!this.encryptionKey) {\n            throw new Error('Encryption key not configured');\n        }\n        const iv = crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes(16);\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createCipheriv('aes-256-gcm', this.encryptionKey, iv);\n        let encrypted = cipher.update(text, 'utf8', 'hex');\n        encrypted += cipher.final('hex');\n        const authTag = cipher.getAuthTag();\n        return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;\n    }\n    // Decrypt encrypted secrets\n    decrypt(encryptedText) {\n        if (!this.encryptionKey) {\n            throw new Error('Encryption key not configured');\n        }\n        const parts = encryptedText.split(':');\n        if (parts.length !== 3) {\n            throw new Error('Invalid encrypted format');\n        }\n        const iv = Buffer.from(parts[0], 'hex');\n        const authTag = Buffer.from(parts[1], 'hex');\n        const encrypted = parts[2];\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);\n        decipher.setAuthTag(authTag);\n        let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n        return decrypted;\n    }\n    // Clear cached secrets\n    clearCache() {\n        this.cache.clear();\n        logger.info('Secrets cache cleared');\n    }\n    // Rotate encryption key\n    async rotateEncryptionKey(newKey) {\n        const oldKey = this.encryptionKey;\n        this.encryptionKey = newKey;\n        // Re-encrypt all file-based secrets\n        const files = await fs_promises__WEBPACK_IMPORTED_MODULE_0__.readdir(this.secretsPath);\n        for (const file of files){\n            if (file.startsWith('.')) continue;\n            try {\n                const filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.secretsPath, file);\n                const content = await fs_promises__WEBPACK_IMPORTED_MODULE_0__.readFile(filePath, 'utf8');\n                // Try to decrypt with old key\n                if (oldKey) {\n                    this.encryptionKey = oldKey;\n                    const decrypted = this.decrypt(content);\n                    // Re-encrypt with new key\n                    this.encryptionKey = newKey;\n                    const encrypted = this.encrypt(decrypted);\n                    await fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile(filePath, encrypted, {\n                        mode: 384\n                    });\n                }\n            } catch (error) {\n                logger.error(`Failed to rotate key for ${file}`, error);\n            }\n        }\n        logger.info('Encryption key rotated successfully');\n    }\n}\n// Export singleton instance\nconst secretsManager = new SecretsManager();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvc2VydmVyL3NlcnZpY2VzL3NlY3JldHNNYW5hZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsNERBQTREO0FBQzVELHdGQUF3RjtBQUV2RDtBQUNMO0FBQ0k7QUFDZ0U7QUFFaEcsTUFBTU0sU0FBUyxJQUFJSCxzRUFBZ0JBLENBQ2pDLG1CQUNBLENBQUMsR0FDREksTUFBcUMsR0FBR0gsQ0FBYUEsR0FBR0MscUVBQWVBO0FBc0J6RSxNQUFNRztJQUtKQyxhQUFjO2FBSk5DLFFBQTZCLElBQUlDO1FBS3ZDLElBQUksQ0FBQ0MsV0FBVyxHQUFHTCxRQUFRTSxHQUFHLENBQUNDLFlBQVksSUFBSWIsc0NBQVMsQ0FBQ00sUUFBUVMsR0FBRyxJQUFJO1FBRXhFLDZEQUE2RDtRQUM3RCxJQUFJVCxRQUFRTSxHQUFHLENBQUNJLHNCQUFzQixFQUFFO1lBQ3RDLElBQUksQ0FBQ0MsYUFBYSxHQUFHQyxPQUFPQyxJQUFJLENBQUNiLFFBQVFNLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUU7UUFDdkU7SUFDRjtJQUVBLE1BQU1JLGFBQTRCO1FBQ2hDLCtDQUErQztRQUMvQyxJQUFJO1lBQ0YsTUFBTXJCLDhDQUFRLENBQUMsSUFBSSxDQUFDWSxXQUFXLEVBQUU7Z0JBQUVXLFdBQVc7Z0JBQU1DLE1BQU07WUFBTTtRQUNsRSxFQUFFLE9BQU9DLE9BQU87WUFDZG5CLE9BQU9tQixLQUFLLENBQUMsc0NBQXNDQTtRQUNyRDtJQUNGO0lBRUEsa0NBQWtDO0lBQ2xDLE1BQU1DLFVBQVVDLElBQVksRUFBRUMsTUFBb0IsRUFBK0I7UUFDL0UsTUFBTUMsV0FBVyxHQUFHRCxPQUFPRSxNQUFNLENBQUMsQ0FBQyxFQUFFSCxNQUFNO1FBRTNDLG9CQUFvQjtRQUNwQixJQUFJLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ3FCLEdBQUcsQ0FBQ0YsV0FBVztZQUM1QixPQUFPLElBQUksQ0FBQ25CLEtBQUssQ0FBQ3NCLEdBQUcsQ0FBQ0g7UUFDeEI7UUFFQSxJQUFJ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R2lGO29CQUNyQixNQUFNaEIsWUFBWSxJQUFJLENBQUNSLE9BQU8sQ0FBQ29CO29CQUUvQixNQUFNL0Ysa0RBQVksQ0FBQzBDLFVBQVV5QyxXQUFXO3dCQUFFM0QsTUFBTTtvQkFBTTtnQkFDeEQ7WUFDRixFQUFFLE9BQU9DLE9BQU87Z0JBQ2RuQixPQUFPbUIsS0FBSyxDQUFDLENBQUMseUJBQXlCLEVBQUU4RSxNQUFNLEVBQUU5RTtZQUNuRDtRQUNGO1FBRUFuQixPQUFPdUUsSUFBSSxDQUFDO0lBQ2Q7QUFDRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNNEIsaUJBQWlCLElBQUlqRyxpQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydWJlZW4vZGV2L3BlcnNvbmFsL2FpcnBvcnQtZGIvc3JjL3NlcnZlci9zZXJ2aWNlcy9zZWNyZXRzTWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZWNyZXRzIE1hbmFnZXIgZm9yIFJlZGlzIGFuZCBvdGhlciBzZW5zaXRpdmUgY3JlZGVudGlhbHNcbi8vIFN1cHBvcnRzIG11bHRpcGxlIHNlY3JldCBzb3VyY2VzOiBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIGZpbGVzLCBhbmQgZXh0ZXJuYWwgc2VydmljZXNcblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMvcHJvbWlzZXMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJ1xuaW1wb3J0IHsgU3RydWN0dXJlZExvZ2dlciwganNvblRyYW5zcG9ydCwgcHJldHR5VHJhbnNwb3J0IH0gZnJvbSAnLi4vLi4vbGliL2NhY2hlL29ic2VydmFiaWxpdHknXG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBTdHJ1Y3R1cmVkTG9nZ2VyKFxuICAnc2VjcmV0cy1tYW5hZ2VyJyxcbiAge30sXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBqc29uVHJhbnNwb3J0IDogcHJldHR5VHJhbnNwb3J0XG4pXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjcmV0Q29uZmlnIHtcbiAgc291cmNlOiAnZW52JyB8ICdmaWxlJyB8ICd2YXVsdCcgfCAnYXdzLXNlY3JldHMtbWFuYWdlcicgfCAnZ2NwLXNlY3JldC1tYW5hZ2VyJ1xuICBwYXRoPzogc3RyaW5nXG4gIGtleT86IHN0cmluZ1xuICBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nXG4gIGRlY3J5cHQ/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjcmV0cyB7XG4gIHJlZGlzUGFzc3dvcmQ/OiBzdHJpbmdcbiAgcmVkaXNVc2VybmFtZT86IHN0cmluZ1xuICByZWRpc1Rsc0NhPzogc3RyaW5nXG4gIHJlZGlzVGxzQ2VydD86IHN0cmluZ1xuICByZWRpc1Rsc0tleT86IHN0cmluZ1xuICBhcGlOaW5qYXNLZXk/OiBzdHJpbmdcbiAgb3BlblNreVVzZXJuYW1lPzogc3RyaW5nXG4gIG9wZW5Ta3lQYXNzd29yZD86IHN0cmluZ1xufVxuXG5jbGFzcyBTZWNyZXRzTWFuYWdlciB7XG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKClcbiAgcHJpdmF0ZSBzZWNyZXRzUGF0aDogc3RyaW5nXG4gIHByaXZhdGUgZW5jcnlwdGlvbktleT86IEJ1ZmZlclxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VjcmV0c1BhdGggPSBwcm9jZXNzLmVudi5TRUNSRVRTX1BBVEggfHwgcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuc2VjcmV0cycpXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBlbmNyeXB0aW9uIGtleSBmcm9tIGVudmlyb25tZW50IG9yIGdlbmVyYXRlIG9uZVxuICAgIGlmIChwcm9jZXNzLmVudi5TRUNSRVRTX0VOQ1JZUFRJT05fS0VZKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBCdWZmZXIuZnJvbShwcm9jZXNzLmVudi5TRUNSRVRTX0VOQ1JZUFRJT05fS0VZLCAnaGV4JylcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENyZWF0ZSBzZWNyZXRzIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLm1rZGlyKHRoaXMuc2VjcmV0c1BhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBtb2RlOiAwbzcwMCB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc2VjcmV0cyBkaXJlY3RvcnknLCBlcnJvciBhcyBFcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgc2VjcmV0IGZyb20gdmFyaW91cyBzb3VyY2VzXG4gIGFzeW5jIGdldFNlY3JldChuYW1lOiBzdHJpbmcsIGNvbmZpZzogU2VjcmV0Q29uZmlnKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke2NvbmZpZy5zb3VyY2V9OiR7bmFtZX1gXG4gICAgXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpXG4gICAgfVxuXG4gICAgbGV0IHNlY3JldDogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICBzd2l0Y2ggKGNvbmZpZy5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2Vudic6XG4gICAgICAgIHNlY3JldCA9IHByb2Nlc3MuZW52W2NvbmZpZy5rZXkgfHwgbmFtZV1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgIHNlY3JldCA9IGF3YWl0IHRoaXMucmVhZFNlY3JldEZyb21GaWxlKGNvbmZpZy5wYXRoIHx8IG5hbWUpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ3ZhdWx0JzpcbiAgICAgICAgc2VjcmV0ID0gYXdhaXQgdGhpcy5yZWFkRnJvbUhhc2hpY29ycFZhdWx0KG5hbWUsIGNvbmZpZylcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnYXdzLXNlY3JldHMtbWFuYWdlcic6XG4gICAgICAgIHNlY3JldCA9IGF3YWl0IHRoaXMucmVhZEZyb21BV1NTZWNyZXRzTWFuYWdlcihuYW1lLCBjb25maWcpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2djcC1zZWNyZXQtbWFuYWdlcic6XG4gICAgICAgIHNlY3JldCA9IGF3YWl0IHRoaXMucmVhZEZyb21HQ1BTZWNyZXRNYW5hZ2VyKG5hbWUsIGNvbmZpZylcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBEZWNyeXB0IGlmIG5lZWRlZFxuICAgIGlmIChzZWNyZXQgJiYgY29uZmlnLmRlY3J5cHQgJiYgdGhpcy5lbmNyeXB0aW9uS2V5KSB7XG4gICAgICBzZWNyZXQgPSB0aGlzLmRlY3J5cHQoc2VjcmV0KVxuICAgIH1cblxuICAgIC8vIENhY2hlIHRoZSBzZWNyZXRcbiAgICBpZiAoc2VjcmV0KSB7XG4gICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgc2VjcmV0KVxuICAgIH1cblxuICAgIHJldHVybiBzZWNyZXRcbiAgfVxuXG4gIC8vIFJlYWQgc2VjcmV0IGZyb20gZmlsZVxuICBwcml2YXRlIGFzeW5jIHJlYWRTZWNyZXRGcm9tRmlsZShmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmlzQWJzb2x1dGUoZmlsZW5hbWUpIFxuICAgICAgICA/IGZpbGVuYW1lIFxuICAgICAgICA6IHBhdGguam9pbih0aGlzLnNlY3JldHNQYXRoLCBmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpXG4gICAgICByZXR1cm4gY29udGVudC50cmltKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKChlcnJvciBhcyBhbnkpLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJlYWQgc2VjcmV0IGZyb20gZmlsZTogJHtmaWxlbmFtZX1gLCBlcnJvciBhcyBFcnJvcilcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvLyBQbGFjZWhvbGRlciBmb3IgSGFzaGlDb3JwIFZhdWx0IGludGVncmF0aW9uXG4gIHByaXZhdGUgYXN5bmMgcmVhZEZyb21IYXNoaWNvcnBWYXVsdChuYW1lOiBzdHJpbmcsIGNvbmZpZzogU2VjcmV0Q29uZmlnKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiB3b3VsZCByZXF1aXJlIHZhdWx0IGNsaWVudCBsaWJyYXJ5XG4gICAgbG9nZ2VyLndhcm4oJ0hhc2hpQ29ycCBWYXVsdCBpbnRlZ3JhdGlvbiBub3QgaW1wbGVtZW50ZWQnLCB7IG5hbWUgfSlcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBQbGFjZWhvbGRlciBmb3IgQVdTIFNlY3JldHMgTWFuYWdlciBpbnRlZ3JhdGlvblxuICBwcml2YXRlIGFzeW5jIHJlYWRGcm9tQVdTU2VjcmV0c01hbmFnZXIobmFtZTogc3RyaW5nLCBjb25maWc6IFNlY3JldENvbmZpZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gd291bGQgcmVxdWlyZSBBV1MgU0RLXG4gICAgbG9nZ2VyLndhcm4oJ0FXUyBTZWNyZXRzIE1hbmFnZXIgaW50ZWdyYXRpb24gbm90IGltcGxlbWVudGVkJywgeyBuYW1lIH0pXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gUGxhY2Vob2xkZXIgZm9yIEdDUCBTZWNyZXQgTWFuYWdlciBpbnRlZ3JhdGlvblxuICBwcml2YXRlIGFzeW5jIHJlYWRGcm9tR0NQU2VjcmV0TWFuYWdlcihuYW1lOiBzdHJpbmcsIGNvbmZpZzogU2VjcmV0Q29uZmlnKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiB3b3VsZCByZXF1aXJlIEdDUCBjbGllbnQgbGlicmFyeVxuICAgIGxvZ2dlci53YXJuKCdHQ1AgU2VjcmV0IE1hbmFnZXIgaW50ZWdyYXRpb24gbm90IGltcGxlbWVudGVkJywgeyBuYW1lIH0pXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gR2V0IGFsbCBzZWNyZXRzIHdpdGggZmFsbGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIGFzeW5jIGdldEFsbFNlY3JldHMoKTogUHJvbWlzZTxTZWNyZXRzPiB7XG4gICAgY29uc3Qgc2VjcmV0czogU2VjcmV0cyA9IHt9XG5cbiAgICAvLyBSZWRpcyBjcmVkZW50aWFsc1xuICAgIHNlY3JldHMucmVkaXNQYXNzd29yZCA9IGF3YWl0IHRoaXMuZ2V0U2VjcmV0KCdSRURJU19QQVNTV09SRCcsIHtcbiAgICAgIHNvdXJjZTogcHJvY2Vzcy5lbnYuU0VDUkVUU19TT1VSQ0UgYXMgYW55IHx8ICdlbnYnLFxuICAgICAga2V5OiAnUkVESVNfUEFTU1dPUkQnXG4gICAgfSkgfHwgcHJvY2Vzcy5lbnYuUkVESVNfUEFTU1dPUkRcblxuICAgIHNlY3JldHMucmVkaXNVc2VybmFtZSA9IGF3YWl0IHRoaXMuZ2V0U2VjcmV0KCdSRURJU19VU0VSTkFNRScsIHtcbiAgICAgIHNvdXJjZTogcHJvY2Vzcy5lbnYuU0VDUkVUU19TT1VSQ0UgYXMgYW55IHx8ICdlbnYnLFxuICAgICAga2V5OiAnUkVESVNfVVNFUk5BTUUnXG4gICAgfSkgfHwgcHJvY2Vzcy5lbnYuUkVESVNfVVNFUk5BTUUgfHwgJ2FpcnBvcnQtYXBwJ1xuXG4gICAgLy8gVExTIGNlcnRpZmljYXRlc1xuICAgIGlmIChwcm9jZXNzLmVudi5SRURJU19UTFNfRU5BQkxFRCA9PT0gJ3RydWUnKSB7XG4gICAgICBzZWNyZXRzLnJlZGlzVGxzQ2EgPSBhd2FpdCB0aGlzLmdldFNlY3JldCgnUkVESVNfVExTX0NBJywge1xuICAgICAgICBzb3VyY2U6ICdmaWxlJyxcbiAgICAgICAgcGF0aDogcHJvY2Vzcy5lbnYuUkVESVNfVExTX0NBIHx8ICdyZWRpcy90bHMvY2EuY3J0J1xuICAgICAgfSlcblxuICAgICAgc2VjcmV0cy5yZWRpc1Rsc0NlcnQgPSBhd2FpdCB0aGlzLmdldFNlY3JldCgnUkVESVNfVExTX0NFUlQnLCB7XG4gICAgICAgIHNvdXJjZTogJ2ZpbGUnLFxuICAgICAgICBwYXRoOiBwcm9jZXNzLmVudi5SRURJU19UTFNfQ0VSVCB8fCAncmVkaXMvdGxzL2NsaWVudC5jcnQnXG4gICAgICB9KVxuXG4gICAgICBzZWNyZXRzLnJlZGlzVGxzS2V5ID0gYXdhaXQgdGhpcy5nZXRTZWNyZXQoJ1JFRElTX1RMU19LRVknLCB7XG4gICAgICAgIHNvdXJjZTogJ2ZpbGUnLFxuICAgICAgICBwYXRoOiBwcm9jZXNzLmVudi5SRURJU19UTFNfS0VZIHx8ICdyZWRpcy90bHMvY2xpZW50LmtleSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gQVBJIGtleXNcbiAgICBzZWNyZXRzLmFwaU5pbmphc0tleSA9IGF3YWl0IHRoaXMuZ2V0U2VjcmV0KCdWSVRFX0FQSV9OSU5KQVNfQVBJX0tFWScsIHtcbiAgICAgIHNvdXJjZTogcHJvY2Vzcy5lbnYuU0VDUkVUU19TT1VSQ0UgYXMgYW55IHx8ICdlbnYnLFxuICAgICAga2V5OiAnVklURV9BUElfTklOSkFTX0FQSV9LRVknXG4gICAgfSlcblxuICAgIHNlY3JldHMub3BlblNreVVzZXJuYW1lID0gYXdhaXQgdGhpcy5nZXRTZWNyZXQoJ1ZJVEVfT1BFTlNLWV9VU0VSTkFNRScsIHtcbiAgICAgIHNvdXJjZTogcHJvY2Vzcy5lbnYuU0VDUkVUU19TT1VSQ0UgYXMgYW55IHx8ICdlbnYnLFxuICAgICAga2V5OiAnVklURV9PUEVOU0tZX1VTRVJOQU1FJ1xuICAgIH0pXG5cbiAgICBzZWNyZXRzLm9wZW5Ta3lQYXNzd29yZCA9IGF3YWl0IHRoaXMuZ2V0U2VjcmV0KCdWSVRFX09QRU5TS1lfUEFTU1dPUkQnLCB7XG4gICAgICBzb3VyY2U6IHByb2Nlc3MuZW52LlNFQ1JFVFNfU09VUkNFIGFzIGFueSB8fCAnZW52JyxcbiAgICAgIGtleTogJ1ZJVEVfT1BFTlNLWV9QQVNTV09SRCdcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNlY3JldHNcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHNlY3VyZSByYW5kb20gcGFzc3dvcmRcbiAgZ2VuZXJhdGVQYXNzd29yZChsZW5ndGg6IG51bWJlciA9IDMyKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGFyc2V0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IUAjJCVeJiooKV8rLT0nXG4gICAgY29uc3QgcmFuZG9tQnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKVxuICAgIGxldCBwYXNzd29yZCA9ICcnXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFzc3dvcmQgKz0gY2hhcnNldFtyYW5kb21CeXRlc1tpXSAlIGNoYXJzZXQubGVuZ3RoXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcGFzc3dvcmRcbiAgfVxuXG4gIC8vIFNhdmUgc2VjcmV0IHRvIGZpbGUgKGZvciBkZXZlbG9wbWVudC9zZXR1cClcbiAgYXN5bmMgc2F2ZVNlY3JldChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGVuY3J5cHQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMuc2VjcmV0c1BhdGgsIG5hbWUpXG4gICAgXG4gICAgbGV0IGNvbnRlbnQgPSB2YWx1ZVxuICAgIGlmIChlbmNyeXB0ICYmIHRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgY29udGVudCA9IHRoaXMuZW5jcnlwdCh2YWx1ZSlcbiAgICB9XG5cbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGNvbnRlbnQsIHsgbW9kZTogMG82MDAgfSlcbiAgICBsb2dnZXIuaW5mbyhgU2VjcmV0IHNhdmVkOiAke25hbWV9YClcbiAgfVxuXG4gIC8vIFNpbXBsZSBlbmNyeXB0aW9uIGZvciBhdC1yZXN0IHByb3RlY3Rpb25cbiAgcHJpdmF0ZSBlbmNyeXB0KHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBrZXkgbm90IGNvbmZpZ3VyZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IGl2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KVxuICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdignYWVzLTI1Ni1nY20nLCB0aGlzLmVuY3J5cHRpb25LZXksIGl2KVxuICAgIFxuICAgIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIudXBkYXRlKHRleHQsICd1dGY4JywgJ2hleCcpXG4gICAgZW5jcnlwdGVkICs9IGNpcGhlci5maW5hbCgnaGV4JylcbiAgICBcbiAgICBjb25zdCBhdXRoVGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKVxuICAgIFxuICAgIHJldHVybiBpdi50b1N0cmluZygnaGV4JykgKyAnOicgKyBhdXRoVGFnLnRvU3RyaW5nKCdoZXgnKSArICc6JyArIGVuY3J5cHRlZFxuICB9XG5cbiAgLy8gRGVjcnlwdCBlbmNyeXB0ZWQgc2VjcmV0c1xuICBwcml2YXRlIGRlY3J5cHQoZW5jcnlwdGVkVGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuZW5jcnlwdGlvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGtleSBub3QgY29uZmlndXJlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBlbmNyeXB0ZWRUZXh0LnNwbGl0KCc6JylcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jcnlwdGVkIGZvcm1hdCcpXG4gICAgfVxuXG4gICAgY29uc3QgaXYgPSBCdWZmZXIuZnJvbShwYXJ0c1swXSwgJ2hleCcpXG4gICAgY29uc3QgYXV0aFRhZyA9IEJ1ZmZlci5mcm9tKHBhcnRzWzFdLCAnaGV4JylcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBwYXJ0c1syXVxuXG4gICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCB0aGlzLmVuY3J5cHRpb25LZXksIGl2KVxuICAgIGRlY2lwaGVyLnNldEF1dGhUYWcoYXV0aFRhZylcblxuICAgIGxldCBkZWNyeXB0ZWQgPSBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkLCAnaGV4JywgJ3V0ZjgnKVxuICAgIGRlY3J5cHRlZCArPSBkZWNpcGhlci5maW5hbCgndXRmOCcpXG5cbiAgICByZXR1cm4gZGVjcnlwdGVkXG4gIH1cblxuICAvLyBDbGVhciBjYWNoZWQgc2VjcmV0c1xuICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGUuY2xlYXIoKVxuICAgIGxvZ2dlci5pbmZvKCdTZWNyZXRzIGNhY2hlIGNsZWFyZWQnKVxuICB9XG5cbiAgLy8gUm90YXRlIGVuY3J5cHRpb24ga2V5XG4gIGFzeW5jIHJvdGF0ZUVuY3J5cHRpb25LZXkobmV3S2V5OiBCdWZmZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvbGRLZXkgPSB0aGlzLmVuY3J5cHRpb25LZXlcbiAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBuZXdLZXlcblxuICAgIC8vIFJlLWVuY3J5cHQgYWxsIGZpbGUtYmFzZWQgc2VjcmV0c1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcih0aGlzLnNlY3JldHNQYXRoKVxuICAgIFxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgaWYgKGZpbGUuc3RhcnRzV2l0aCgnLicpKSBjb250aW51ZVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLnNlY3JldHNQYXRoLCBmaWxlKVxuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4JylcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBkZWNyeXB0IHdpdGggb2xkIGtleVxuICAgICAgICBpZiAob2xkS2V5KSB7XG4gICAgICAgICAgdGhpcy5lbmNyeXB0aW9uS2V5ID0gb2xkS2V5XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5kZWNyeXB0KGNvbnRlbnQpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmUtZW5jcnlwdCB3aXRoIG5ldyBrZXlcbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBuZXdLZXlcbiAgICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSB0aGlzLmVuY3J5cHQoZGVjcnlwdGVkKVxuICAgICAgICAgIFxuICAgICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgZW5jcnlwdGVkLCB7IG1vZGU6IDBvNjAwIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJvdGF0ZSBrZXkgZm9yICR7ZmlsZX1gLCBlcnJvciBhcyBFcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2dnZXIuaW5mbygnRW5jcnlwdGlvbiBrZXkgcm90YXRlZCBzdWNjZXNzZnVsbHknKVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBzZWNyZXRzTWFuYWdlciA9IG5ldyBTZWNyZXRzTWFuYWdlcigpIl0sIm5hbWVzIjpbImZzIiwicGF0aCIsImNyeXB0byIsIlN0cnVjdHVyZWRMb2dnZXIiLCJqc29uVHJhbnNwb3J0IiwicHJldHR5VHJhbnNwb3J0IiwibG9nZ2VyIiwicHJvY2VzcyIsIlNlY3JldHNNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJjYWNoZSIsIk1hcCIsInNlY3JldHNQYXRoIiwiZW52IiwiU0VDUkVUU19QQVRIIiwiam9pbiIsImN3ZCIsIlNFQ1JFVFNfRU5DUllQVElPTl9LRVkiLCJlbmNyeXB0aW9uS2V5IiwiQnVmZmVyIiwiZnJvbSIsImluaXRpYWxpemUiLCJta2RpciIsInJlY3Vyc2l2ZSIsIm1vZGUiLCJlcnJvciIsImdldFNlY3JldCIsIm5hbWUiLCJjb25maWciLCJjYWNoZUtleSIsInNvdXJjZSIsImhhcyIsImdldCIsInNlY3JldCIsImtleSIsInJlYWRTZWNyZXRGcm9tRmlsZSIsInJlYWRGcm9tSGFzaGljb3JwVmF1bHQiLCJyZWFkRnJvbUFXU1NlY3JldHNNYW5hZ2VyIiwicmVhZEZyb21HQ1BTZWNyZXRNYW5hZ2VyIiwiZGVjcnlwdCIsInNldCIsImZpbGVuYW1lIiwiZmlsZVBhdGgiLCJpc0Fic29sdXRlIiwiY29udGVudCIsInJlYWRGaWxlIiwidHJpbSIsImNvZGUiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZ2V0QWxsU2VjcmV0cyIsInNlY3JldHMiLCJyZWRpc1Bhc3N3b3JkIiwiU0VDUkVUU19TT1VSQ0UiLCJSRURJU19QQVNTV09SRCIsInJlZGlzVXNlcm5hbWUiLCJSRURJU19VU0VSTkFNRSIsIlJFRElTX1RMU19FTkFCTEVEIiwicmVkaXNUbHNDYSIsIlJFRElTX1RMU19DQSIsInJlZGlzVGxzQ2VydCIsIlJFRElTX1RMU19DRVJUIiwicmVkaXNUbHNLZXkiLCJSRURJU19UTFNfS0VZIiwiYXBpTmluamFzS2V5Iiwib3BlblNreVVzZXJuYW1lIiwib3BlblNreVBhc3N3b3JkIiwiZ2VuZXJhdGVQYXNzd29yZCIsImxlbmd0aCIsImNoYXJzZXQiLCJyYW5kb21CeXRlcyIsInBhc3N3b3JkIiwiaSIsInNhdmVTZWNyZXQiLCJ2YWx1ZSIsImVuY3J5cHQiLCJ3cml0ZUZpbGUiLCJpbmZvIiwidGV4dCIsIkVycm9yIiwiaXYiLCJjaXBoZXIiLCJjcmVhdGVDaXBoZXJpdiIsImVuY3J5cHRlZCIsInVwZGF0ZSIsImZpbmFsIiwiYXV0aFRhZyIsImdldEF1dGhUYWciLCJ0b1N0cmluZyIsImVuY3J5cHRlZFRleHQiLCJwYXJ0cyIsInNwbGl0IiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2Iiwic2V0QXV0aFRhZyIsImRlY3J5cHRlZCIsImNsZWFyQ2FjaGUiLCJjbGVhciIsInJvdGF0ZUVuY3J5cHRpb25LZXkiLCJuZXdLZXkiLCJvbGRLZXkiLCJmaWxlcyIsInJlYWRkaXIiLCJmaWxlIiwic3RhcnRzV2l0aCIsInNlY3JldHNNYW5hZ2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/server/services/secretsManager.ts\n");

/***/ })

};
;